#!/usr/bin/env python3
"""
Dependency Scanner for Skippy System Manager
Version: 1.0.0
Purpose: Scan Python scripts and generate requirements.txt files
Usage: python3 scan_dependencies_v1.0.0.py [--category CATEGORY] [--output FILE]
"""

import ast
import argparse
import sys
from pathlib import Path
from collections import defaultdict
from typing import Set, Dict, List

# Standard library modules (should not be in requirements.txt)
STDLIB_MODULES = {
    'abc', 'argparse', 'ast', 'asyncio', 'base64', 'collections', 'concurrent',
    'configparser', 'contextlib', 'copy', 'csv', 'datetime', 'decimal', 'email',
    'enum', 'functools', 'glob', 'gzip', 'hashlib', 'html', 'http', 'io', 'itertools',
    'json', 'logging', 'math', 'multiprocessing', 'os', 'pathlib', 'pickle', 'platform',
    'queue', 're', 'shutil', 'signal', 'socket', 'sqlite3', 'ssl', 'string', 'subprocess',
    'sys', 'tempfile', 'textwrap', 'threading', 'time', 'traceback', 'typing', 'unittest',
    'urllib', 'uuid', 'warnings', 'weakref', 'xml', 'zipfile'
}

# Known package mappings (import name -> package name)
PACKAGE_MAPPINGS = {
    'PIL': 'Pillow',
    'yaml': 'PyYAML',
    'dotenv': 'python-dotenv',
    'dateutil': 'python-dateutil',
    'jwt': 'PyJWT',
    'MySQLdb': 'mysqlclient',
    'cv2': 'opencv-python',
    'sklearn': 'scikit-learn',
}


class DependencyScanner:
    """Scan Python files for dependencies"""

    def __init__(self):
        self.dependencies: Dict[str, Set[str]] = defaultdict(set)

    def extract_imports(self, file_path: Path) -> Set[str]:
        """Extract imports from a Python file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                tree = ast.parse(f.read(), filename=str(file_path))
        except SyntaxError:
            print(f"‚ö†Ô∏è  Syntax error in {file_path}, skipping", file=sys.stderr)
            return set()
        except Exception as e:
            print(f"‚ö†Ô∏è  Error reading {file_path}: {e}", file=sys.stderr)
            return set()

        imports = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    # Get top-level module name
                    module = alias.name.split('.')[0]
                    imports.add(module)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    # Get top-level module name
                    module = node.module.split('.')[0]
                    imports.add(module)

        return imports

    def filter_stdlib(self, imports: Set[str]) -> Set[str]:
        """Filter out standard library modules"""
        return {imp for imp in imports if imp not in STDLIB_MODULES}

    def map_package_names(self, imports: Set[str]) -> Set[str]:
        """Map import names to package names"""
        return {PACKAGE_MAPPINGS.get(imp, imp) for imp in imports}

    def scan_directory(self, directory: Path, category: str = "general"):
        """Scan all Python files in a directory"""
        if not directory.exists():
            print(f"‚ö†Ô∏è  Directory not found: {directory}", file=sys.stderr)
            return

        python_files = list(directory.rglob('*.py'))
        print(f"üìÅ Scanning {len(python_files)} Python files in {directory}")

        for file_path in python_files:
            # Skip test files and virtual environments
            if any(part in file_path.parts for part in ['.venv', 'venv', '__pycache__', 'test_']):
                continue

            imports = self.extract_imports(file_path)
            filtered_imports = self.filter_stdlib(imports)
            packages = self.map_package_names(filtered_imports)

            self.dependencies[category].update(packages)

    def generate_requirements(self, output_file: Path):
        """Generate requirements.txt file"""
        if not self.dependencies:
            print("‚ö†Ô∏è  No dependencies found", file=sys.stderr)
            return

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Auto-generated requirements file\n")
            f.write("# Generated by scan_dependencies_v1.0.0.py\n\n")

            for category, packages in sorted(self.dependencies.items()):
                if packages:
                    f.write(f"# {category}\n")
                    for package in sorted(packages):
                        f.write(f"{package}\n")
                    f.write("\n")

        print(f"‚úÖ Generated requirements file: {output_file}")
        print(f"   Total packages: {sum(len(p) for p in self.dependencies.values())}")

    def print_summary(self):
        """Print dependency summary"""
        print("\nüìä Dependency Summary:")
        print("=" * 60)

        for category, packages in sorted(self.dependencies.items()):
            print(f"\n{category.upper()}: {len(packages)} packages")
            for package in sorted(packages):
                print(f"  ‚Ä¢ {package}")


def main():
    parser = argparse.ArgumentParser(
        description="Scan Python scripts for dependencies"
    )
    parser.add_argument(
        '--category',
        default='general',
        help='Category to scan (e.g., automation, wordpress)'
    )
    parser.add_argument(
        '--output',
        default='requirements-scanned.txt',
        help='Output requirements file'
    )
    parser.add_argument(
        '--directory',
        help='Directory to scan (default: current directory)'
    )
    parser.add_argument(
        '--all-categories',
        action='store_true',
        help='Scan all script categories'
    )

    args = parser.parse_args()

    scanner = DependencyScanner()

    if args.all_categories:
        # Scan all script categories
        base_dir = Path(__file__).parent.parent.parent
        categories = [
            ('automation', base_dir / 'scripts' / 'automation'),
            ('wordpress', base_dir / 'scripts' / 'wordpress'),
            ('security', base_dir / 'scripts' / 'security'),
            ('monitoring', base_dir / 'scripts' / 'monitoring'),
            ('lib', base_dir / 'lib' / 'python'),
            ('mcp-server', base_dir / 'mcp-servers' / 'general-server'),
        ]

        for category, directory in categories:
            if directory.exists():
                scanner.scan_directory(directory, category)
    else:
        # Scan specified directory
        if args.directory:
            directory = Path(args.directory)
        else:
            directory = Path.cwd()

        scanner.scan_directory(directory, args.category)

    # Generate requirements file
    output_file = Path(args.output)
    scanner.generate_requirements(output_file)

    # Print summary
    scanner.print_summary()


if __name__ == "__main__":
    main()
